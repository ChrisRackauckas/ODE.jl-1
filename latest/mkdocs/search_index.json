{
    "docs": [
        {
            "location": "/", 
            "text": "Basic usage\n\n\n\n\n\n\nODE.jl\n\n\n\n\nTop level interface\n\n\nIf you are looking to getting a solution without the additional hussle of handling an iterator we provide the wrappers \nODE.odeXX\n.  They provide a simplistic way of handling explicit differential equations of the form \ny'=F(t,y)\n with \ny\n being either a \nNumber\n or an \nAbstractArray\n of any dimension.  Below we solve a simple initial value problem given by \ny'=y\n with initial data at \nt0=0.0\n and \ny0=1.0\n on the interval \n[t0,1]\n.\n\n\nusing ODE\ntspan  = [0.0,1.0]\ny0     = 1.0\nF(t,y) = y\n(t,y)  = ODE.ode(F,y0,tspan)\n\n\n\n\n([6.05545e-6,3.63327e-5,0.000187719,0.000944651,0.00472931,0.0236526,0.118269,0.295886,0.477652,0.659618,0.841585,1.0],[1.00001,1.00004,1.00019,1.00095,1.00474,1.02393,1.12555,1.34432,1.61228,1.93405,2.32004,2.71828])\n\n\n\n\nThe vectors \nt\n and \ny\n store the time and solution values at the corresponding times.\n\n\nYou might find the basic interface limiting.  First of all, it stores all the results, so if you are only interested in the final value of \ny\n it still stores all the intermediate steps.  Secondly, you cannot process the results on the fly (e.g. plot the current state of a solution).  If you need more control you should consider using the iterator interface.\n\n\n\n\nIterator interface\n\n\nTo offeset the limitations of the \nODE.ode\n interface we implemented a general.  First we define an initial value problem, in our case this is an explicit differential equation \ny'=y\n with inital data \ny0=[1.0]\n given at the time \nt0=0.0\n.\n\n\nusing ODE\nt0  = 0.0\ny0  = [1.0]\nF!(t,y,dy) = dy[1]=y[1]\node = ODE.ExplicitODE(t0,y0,F!)\n\n\n\n\nODE.IVP{Float64,Array{Float64,1},Function,Void,Function}(0.0,[1.0],[6.90438e-310],ex-iterator.F!,nothing,ODE.jac!)\n\n\n\n\nNote that unlike in \nODE.ode\n we now have to supply an in place function \nF!\n instead of an explicit function \nF\n.  Now we are ready to produce the iterator that solvese to our problem.\n\n\nsol = ODE.solve(ode)\nfor (t,y) in sol\n    @show (t,y)\n    if t \n 1\n        break\n    end\nend\n\n\n\n\n(t,y) = (6.055454452393343e-6,[1.00001])\n(t,y) = (3.633272671436006e-5,[1.00004])\n(t,y) = (0.00018771908802419363,[1.00019])\n(t,y) = (0.0009446508945733616,[1.00095])\n(t,y) = (0.004729309927319202,[1.00474])\n(t,y) = (0.023652605091048398,[1.02393])\n(t,y) = (0.11826908090969439,[1.12555])\n(t,y) = (0.2958859009223397,[1.34432])\n(t,y) = (0.47765152348716255,[1.61228])\n(t,y) = (0.6596176824666204,[1.93405])\n(t,y) = (0.8415848484689563,[2.32004])\n(t,y) = (1.0235443711828829,[2.78304])\n\n\n\n\nNote that we had to interrupt the loop because \nsol\n would be producing solutions ad infinitum (in theory, in practice we will get to the point where the solver won't be able to produce reasonable solution anymore).  To set the final integration time and other parameters of the integrator \ninteg\n we can pass optional arguments to \nODE.solver\n.\n\n\nsol = ODE.solve(ode; tstop = 1)\nfor (t,y) in sol\n    @show (t,y)\nend\n\n\n\n\n(t,y) = (6.055454452393343e-6,[1.00001])\n(t,y) = (3.633272671436006e-5,[1.00004])\n(t,y) = (0.00018771908802419363,[1.00019])\n(t,y) = (0.0009446508945733616,[1.00095])\n(t,y) = (0.004729309927319202,[1.00474])\n(t,y) = (0.023652605091048398,[1.02393])\n(t,y) = (0.11826908090969439,[1.12555])\n(t,y) = (0.2958859009223397,[1.34432])\n(t,y) = (0.47765152348716255,[1.61228])\n(t,y) = (0.6596176824666204,[1.93405])\n(t,y) = (0.8415848484689563,[2.32004])\n(t,y) = (1.0,[2.71828])\n\n\n\n\nThis approach has the added benefit of the solution never exceeding the final time.  Apart from the time and value \n(t,y)\n the \nODE.solve\n returns also the derivative, you can retrive it as the third argument in the returned tuple.  In the following example we use it compute the absolute error.\n\n\nsol = ODE.solve(ode; tstop = 1)\nfor (t,y,dy) in sol\n    err = norm(y-dy)\n    @show err\nend\n\n\n\n\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\n\n\n\n\nWith \ntstop\n specified we can also get all results at once using \ncollect\n.\n\n\nres = collect(sol)\n\n\n\n\n12-element Array{Tuple{Float64,Array{Float64,1},Array{Float64,1}},1}:\n (6.05545e-6,[1.00001],[1.00001])\n (3.63327e-5,[1.00004],[1.00004])\n (0.000187719,[1.00019],[1.00019])\n (0.000944651,[1.00095],[1.00095])\n (0.00472931,[1.00474],[1.00474])\n (0.0236526,[1.02393],[1.02393])\n (0.118269,[1.12555],[1.12555])\n (0.295886,[1.34432],[1.34432])\n (0.477652,[1.61228],[1.61228])\n (0.659618,[1.93405],[1.93405])\n (0.841585,[2.32004],[2.32004])\n (1.0,[2.71828],[2.71828])\n\n\n\n\nNote that \ncollect\n returns a vector of triples \n(t,y,dy)\n.\n\n\n\n\nOptions\n\n\nBoth \nODE.ode\n and \nODE.solve\n accept the following keyword arguments.\n\n\n\n\ninteg\n: the type of integrator to use, defaults to a adaptive Runge-Kutta method of order 4/5.  To see the list of available integrators see \nIntegrators\n.\n\n\ninitstep\n: The initial step size, defaults to \neps(T)^(1/3)\n.\n\n\ntstop\n: The final integration time, never exceeded by the integrator.  In case of \nODE.ode(F,y0,tspan)\n this option defaults to the last element of \ntspan\n if it is a vector.  In \nODE.solve\n the default is \ntstop=Inf\n.  If \ntstop\n is smaller then \nt0\n the integration runs backwards in time.\n\n\n\n\nApart from these general options, each integrator has its own keyword arguments.  In particular all integrators with adaptive step size can be cotrolled with\n\n\n\n\nreltol\n, \nabstol\n: The relative and absolute error tolerances.  The solution guarantees that at each step we have \nnorm((y-yc)*reltol.+abstol)\n=1\n, where \nyc\n is a true solution to and IVP.  Defaults are \nreltol=eps(T)^(1/3)/10\n, \nabstol=eps(T)^(1/2)/10\n.\n\n\nnorm\n: The norm used to measure error in the formula above, defaults to \ny-\nBase.vecnorm(y,Inf)\n.  You can specify it to assign different weights to different components of \ny\n.\n\n\nminstep\n, \nmaxstep\n: Minimal and maximal stepsize for the integrator.  If at any point the stepsize exceeds these limits the integrator will yield an error and cease producing results.  Deafaults are \nminstep=10*eps(T)\n and \nmaxstep=1/minstep\n.\n\n\nmaxiters\n: The number of iterations before the integrator ceases to work, defaults to \nInf\n.  Useful as a safeguard from iterator continuing ad infinitum.\n\n\nisoutofdomain\n: Applied to each component of \ny\n, if \nisoutofdomain(y[i])==true\n the integrator stops.  Defaults to \nBase.isnan\n.\n\n\n\n\nApart from these, each integrator may support additional options.\n\n\n\n\nIntegrators\n\n\n\n\nExplicit Runge-Kutta integrators\n\n\n\n\nRosenbrock methods\n\n\n\n\nBackwards differential formula (BDF) methods\n\n\n\n\n???", 
            "title": "Home"
        }, 
        {
            "location": "/#odejl", 
            "text": "", 
            "title": "ODE.jl"
        }, 
        {
            "location": "/#top-level-interface", 
            "text": "If you are looking to getting a solution without the additional hussle of handling an iterator we provide the wrappers  ODE.odeXX .  They provide a simplistic way of handling explicit differential equations of the form  y'=F(t,y)  with  y  being either a  Number  or an  AbstractArray  of any dimension.  Below we solve a simple initial value problem given by  y'=y  with initial data at  t0=0.0  and  y0=1.0  on the interval  [t0,1] .  using ODE\ntspan  = [0.0,1.0]\ny0     = 1.0\nF(t,y) = y\n(t,y)  = ODE.ode(F,y0,tspan)  ([6.05545e-6,3.63327e-5,0.000187719,0.000944651,0.00472931,0.0236526,0.118269,0.295886,0.477652,0.659618,0.841585,1.0],[1.00001,1.00004,1.00019,1.00095,1.00474,1.02393,1.12555,1.34432,1.61228,1.93405,2.32004,2.71828])  The vectors  t  and  y  store the time and solution values at the corresponding times.  You might find the basic interface limiting.  First of all, it stores all the results, so if you are only interested in the final value of  y  it still stores all the intermediate steps.  Secondly, you cannot process the results on the fly (e.g. plot the current state of a solution).  If you need more control you should consider using the iterator interface.", 
            "title": "Top level interface"
        }, 
        {
            "location": "/#iterator-interface", 
            "text": "To offeset the limitations of the  ODE.ode  interface we implemented a general.  First we define an initial value problem, in our case this is an explicit differential equation  y'=y  with inital data  y0=[1.0]  given at the time  t0=0.0 .  using ODE\nt0  = 0.0\ny0  = [1.0]\nF!(t,y,dy) = dy[1]=y[1]\node = ODE.ExplicitODE(t0,y0,F!)  ODE.IVP{Float64,Array{Float64,1},Function,Void,Function}(0.0,[1.0],[6.90438e-310],ex-iterator.F!,nothing,ODE.jac!)  Note that unlike in  ODE.ode  we now have to supply an in place function  F!  instead of an explicit function  F .  Now we are ready to produce the iterator that solvese to our problem.  sol = ODE.solve(ode)\nfor (t,y) in sol\n    @show (t,y)\n    if t   1\n        break\n    end\nend  (t,y) = (6.055454452393343e-6,[1.00001])\n(t,y) = (3.633272671436006e-5,[1.00004])\n(t,y) = (0.00018771908802419363,[1.00019])\n(t,y) = (0.0009446508945733616,[1.00095])\n(t,y) = (0.004729309927319202,[1.00474])\n(t,y) = (0.023652605091048398,[1.02393])\n(t,y) = (0.11826908090969439,[1.12555])\n(t,y) = (0.2958859009223397,[1.34432])\n(t,y) = (0.47765152348716255,[1.61228])\n(t,y) = (0.6596176824666204,[1.93405])\n(t,y) = (0.8415848484689563,[2.32004])\n(t,y) = (1.0235443711828829,[2.78304])  Note that we had to interrupt the loop because  sol  would be producing solutions ad infinitum (in theory, in practice we will get to the point where the solver won't be able to produce reasonable solution anymore).  To set the final integration time and other parameters of the integrator  integ  we can pass optional arguments to  ODE.solver .  sol = ODE.solve(ode; tstop = 1)\nfor (t,y) in sol\n    @show (t,y)\nend  (t,y) = (6.055454452393343e-6,[1.00001])\n(t,y) = (3.633272671436006e-5,[1.00004])\n(t,y) = (0.00018771908802419363,[1.00019])\n(t,y) = (0.0009446508945733616,[1.00095])\n(t,y) = (0.004729309927319202,[1.00474])\n(t,y) = (0.023652605091048398,[1.02393])\n(t,y) = (0.11826908090969439,[1.12555])\n(t,y) = (0.2958859009223397,[1.34432])\n(t,y) = (0.47765152348716255,[1.61228])\n(t,y) = (0.6596176824666204,[1.93405])\n(t,y) = (0.8415848484689563,[2.32004])\n(t,y) = (1.0,[2.71828])  This approach has the added benefit of the solution never exceeding the final time.  Apart from the time and value  (t,y)  the  ODE.solve  returns also the derivative, you can retrive it as the third argument in the returned tuple.  In the following example we use it compute the absolute error.  sol = ODE.solve(ode; tstop = 1)\nfor (t,y,dy) in sol\n    err = norm(y-dy)\n    @show err\nend  err = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0\nerr = 0.0  With  tstop  specified we can also get all results at once using  collect .  res = collect(sol)  12-element Array{Tuple{Float64,Array{Float64,1},Array{Float64,1}},1}:\n (6.05545e-6,[1.00001],[1.00001])\n (3.63327e-5,[1.00004],[1.00004])\n (0.000187719,[1.00019],[1.00019])\n (0.000944651,[1.00095],[1.00095])\n (0.00472931,[1.00474],[1.00474])\n (0.0236526,[1.02393],[1.02393])\n (0.118269,[1.12555],[1.12555])\n (0.295886,[1.34432],[1.34432])\n (0.477652,[1.61228],[1.61228])\n (0.659618,[1.93405],[1.93405])\n (0.841585,[2.32004],[2.32004])\n (1.0,[2.71828],[2.71828])  Note that  collect  returns a vector of triples  (t,y,dy) .", 
            "title": "Iterator interface"
        }, 
        {
            "location": "/#options", 
            "text": "Both  ODE.ode  and  ODE.solve  accept the following keyword arguments.   integ : the type of integrator to use, defaults to a adaptive Runge-Kutta method of order 4/5.  To see the list of available integrators see  Integrators .  initstep : The initial step size, defaults to  eps(T)^(1/3) .  tstop : The final integration time, never exceeded by the integrator.  In case of  ODE.ode(F,y0,tspan)  this option defaults to the last element of  tspan  if it is a vector.  In  ODE.solve  the default is  tstop=Inf .  If  tstop  is smaller then  t0  the integration runs backwards in time.   Apart from these general options, each integrator has its own keyword arguments.  In particular all integrators with adaptive step size can be cotrolled with   reltol ,  abstol : The relative and absolute error tolerances.  The solution guarantees that at each step we have  norm((y-yc)*reltol.+abstol) =1 , where  yc  is a true solution to and IVP.  Defaults are  reltol=eps(T)^(1/3)/10 ,  abstol=eps(T)^(1/2)/10 .  norm : The norm used to measure error in the formula above, defaults to  y- Base.vecnorm(y,Inf) .  You can specify it to assign different weights to different components of  y .  minstep ,  maxstep : Minimal and maximal stepsize for the integrator.  If at any point the stepsize exceeds these limits the integrator will yield an error and cease producing results.  Deafaults are  minstep=10*eps(T)  and  maxstep=1/minstep .  maxiters : The number of iterations before the integrator ceases to work, defaults to  Inf .  Useful as a safeguard from iterator continuing ad infinitum.  isoutofdomain : Applied to each component of  y , if  isoutofdomain(y[i])==true  the integrator stops.  Defaults to  Base.isnan .   Apart from these, each integrator may support additional options.", 
            "title": "Options"
        }, 
        {
            "location": "/#integrators", 
            "text": "", 
            "title": "Integrators"
        }, 
        {
            "location": "/#explicit-runge-kutta-integrators", 
            "text": "", 
            "title": "Explicit Runge-Kutta integrators"
        }, 
        {
            "location": "/#rosenbrock-methods", 
            "text": "", 
            "title": "Rosenbrock methods"
        }, 
        {
            "location": "/#backwards-differential-formula-bdf-methods", 
            "text": "", 
            "title": "Backwards differential formula (BDF) methods"
        }, 
        {
            "location": "/#_1", 
            "text": "", 
            "title": "???"
        }, 
        {
            "location": "/man/basics/", 
            "text": "Basic usage\n\n\nConsider an ODE $y'=y$", 
            "title": "Basics"
        }, 
        {
            "location": "/man/basics/#basic-usage", 
            "text": "Consider an ODE $y'=y$", 
            "title": "Basic usage"
        }, 
        {
            "location": "/man/base/", 
            "text": "#\n\n\nODE.accept!\n \n \nMethod\n.\n\n\nAccepts (in-place) the computed step.  Called if \nerrorcontrol!\n gave a small enough error.\n\n\nReturns \nStatus\n.\n\n\nsource\n\n\n#\n\n\nODE.errorcontrol!\n \n \nMethod\n.\n\n\nEstimates the error (such that a step is accepted if err\n=1). Depending on the stepper it may update the state, e.g. by computing a new dt or a new order (but not by computing a new solution!).\n\n\nReturns \n(err,Status)\n.\n\n\nIf the \nstatus==abort\n then the integration is aborted, status values of \ncont\n and \nfinish\n are ignored.\n\n\nsource\n\n\n#\n\n\nODE.explicit_ineff\n \n \nMethod\n.\n\n\nConvert a out-of-place explicitly defined ODE function to ExplicitODE.  As the name suggests, the result is not going to be very efficient.\n\n\nsource\n\n\n#\n\n\nODE.interpolate!\n \n \nFunction\n.\n\n\nMakes dense output\n\n\ninterpolate!(istate::AbstractState, step_prev::Step, tout, step_out::Step)\n\n\nInput:\n\n\n\n\nistate::AbstractState\n state of the integrator\n\n\nstep_prev\n the previous step, part of \ndstate\n\n\ntout \u2013 time of requested output\n\n\nstep_out::Step \u2013 inplace output step\n\n\n\n\nOutput: nothing\n\n\nTODO: output dy too\n\n\nTOOD: provide arbitrary order dense output. Maybe use work of @obiajulu on A-B-M methods.\n\n\nsource\n\n\n#\n\n\nODE.interpolate!\n \n \nMethod\n.\n\n\nMake dense output using Hermite interpolation of order O(3), should work for most integrators and is used as default.  This only needs y and dy at t1 and t2.\n\n\nRef: Hairer \n Wanner p.190\n\n\nsource\n\n\n#\n\n\nODE.next_interval!\n \n \nMethod\n.\n\n\nTakes steps using the underlying integrator until it reaches a first step such that \nt\n=tout\n.  It fills the \nsteps\n variable with (Step(t1,y(t1),dy(t1)),Step(t2,y(t2),dy(t2))), where \nt1\n is is the step before \ntout\n and \nt2\n is \n=tout\n.  In other words \ntout\u2208[t1,t2]\n.\n\n\nsource\n\n\n#\n\n\nODE.ode\n \n \nMethod\n.\n\n\nWe assume that the initial data y0 is given at tspan[1], and that tspan[end] is the last integration time.\n\n\nsource\n\n\n#\n\n\nODE.ode23s\n \n \nMethod\n.\n\n\nODE.odeXX(F,y0,t0;kargs...)\n\n\n\n\nSolves an ODE \ny'=F(t,y)\n with initial conditions \ny0\n and \nt0\n.\n\n\nsource\n\n\n#\n\n\nODE.onestep!\n \n \nMethod\n.\n\n\nTake a step, modifies \nstate\n in-place.  This is the core function to be implemented by a solver.  However, if possible solvers should opt to implement the sub-step functions \ntrialstep!\n, \nerrorcontrol!\n and \naccept!\n, instead of directly \nonestep!\n.\n\n\nInput:\n\n\n\n\nprob::Problem, state::AbstractState\n\n\n\n\nOutput:\n\n\n\n\nBool: \nfalse\n: continue iteration, \ntrue\n: terminate iteration.\n\n\n\n\nsubsteps.\n\n\nsource\n\n\n#\n\n\nODE.onestep!\n \n \nMethod\n.\n\n\nTODO: rename \ntout\n to \ntout\n and drop the support for \npoints=:all\n outside of the \nodeXX\n?  Maybe even \nodeXX(;tout=[...])\n would use dense output while \nodeXX(;)\n wouldn't.\n\n\nsource\n\n\n#\n\n\nODE.output\n \n \nMethod\n.\n\n\nReturns variables returned during iterations.\n\n\noutput(st::AbstractState) = t,y,dy\n\n\nsource\n\n\n#\n\n\nODE.solve\n \n \nMethod\n.\n\n\nsolve(ivp::IVP, solver::Type{AbstractSolver}, opts...)\nsolve(ivp::IVP; solver=RKIntegratorAdaptive{:rk45}, opts...)\n\n\n\n\nSolve creates an iterable \nProblem\n instance from an \nIVP\n instance (specifying the math) and from a \nType{AbstractSolver}\n (the numerical integrator).  The simplest use case is\n\n\nfor (t,y,dy) in solver(...)\n    # do something with t, y an dy\nend\n\n\n\n\nIf the integration interval, defined by the keyword argument \ntstop\n, is finite you can request all the results at once by calling ``` collect(solver(...)) # =\n Vector{Tuple{T,Y,Y}}\n\n\nNotes:\n\n\n\n\nusually a solvers requires the ivp to be in a certain form, say an\n\n\n\n\nExplicitODE\n. - the second argument it the \nType\n of the solver and not an instance.   The instance of the solve can only be created together with the   \nivp\n as their type parameters need to match.\n\n\nInput:\n\n\n\n\nivp::IVP\n\n\nS::Type{AbstractSolver}\n\n\n\n\nOutput:\n\n\n\n\n::Problem\n\n\n\n\nsource\n\n\n#\n\n\nODE.trialstep!\n \n \nMethod\n.\n\n\nAdvances the solution by trying to compute a single step.  The new step is kept in the \nstate\n in work arrays so that \nerrorcontrol!\n can compute the magnitude of its error.  If the error is small enough \naccept!\n updates \nstate\n to reflect the state at the new time.\n\n\nReturns \nStatus\n.\n\n\nsource\n\n\n#\n\n\nODE.AbstractIntegrator\n \n \nType\n.\n\n\nThe abstract type of the actual algorithm to solve an IVP.\n\n\nsource\n\n\n#\n\n\nODE.AbstractSolver\n \n \nType\n.\n\n\nThe supertype of anything which can get you to a solution of a IVP. Subtypes include: \nAbstractIntegrator\ns but also \nDenseOutput\n\n\nsource\n\n\n#\n\n\nODE.AbstractState\n \n \nType\n.\n\n\nAbstractState keeps the temporary data (state) for the iterator Problem{::AbstractIntegrator}.\n\n\nsource\n\n\n#\n\n\nODE.AdaptiveOptions\n \n \nType\n.\n\n\nGeneric options for adaptive ODE solvers.  This type has a key-word constructor which will fill the structure with default values.\n\n\nGeneral:\n\n\n\n\ninitstep ::T  initial step size (always positive)\n\n\ntstop    ::T  end integration time\n\n\nreltol   ::T  relative tolerance (m3: could this be a vector?)\n\n\nabstol   ::T  absolute tolerance (m3: could this be a vector?)\n\n\nminstep  ::T  minimal allowed step size (always positive)\n\n\nmaxstep  ::T  maximal allowed step size (always positive)\n\n\nnorm          function to calculate the norm in step control\n\n\nmaxiters ::T  maximum number of steps\n\n\nisoutofdomain::Function checks if the solution is outside of the allowed domain\n\n\n\n\nsource\n\n\n#\n\n\nODE.DenseOptions\n \n \nType\n.\n\n\nDense output options:\n\n\n\n\ntout    ::Vector{T}  output times\n\n\n\n\nTODO options:\n\n\n\n\npoints   ::Symbol which points are returned: \n:specified\n only the ones in tspan or \n:all\n which includes also the step-points of the solver.\n\n\nstopevent   Stop integration at a zero of this function\n\n\nroottol\n\n\n\n\nsource\n\n\n#\n\n\nODE.DenseOutput\n \n \nType\n.\n\n\nA solver specialized in dense output; it wraps an integrator. It stores the subsequent steps generated by \nProblem\n and interpolates the results (currently this means at the output times stored in \nopts.tout\n).\n\n\nsource\n\n\n#\n\n\nODE.DenseState\n \n \nType\n.\n\n\nThe state of the dense solver \nDenseOutput\n.\n\n\nsource\n\n\n#\n\n\nODE.FixedOptions\n \n \nType\n.\n\n\nGeneric options for fixed step ODE solvers.  This type has a key-word constructor which will fill the structure with default values.\n\n\nGeneral:\n\n\n\n\ninitstep ::T  initial step (always positive)\n\n\ntstop    ::T  end integration time\n\n\n\n\nsource\n\n\n#\n\n\nODE.IVP\n \n \nType\n.\n\n\nDefines the mathematical part of an IVP (initial value problem) specified in the general form:\n\n\nF(t, y) =  G(t, y, dy)\n with \ny(t0)= y0\n\n\nDepending on the combination of the parameters this type can represent a wide range of problems, including ODE, DAE and IMEX.  Nevertheless not all solvers will support any combinations of \nF\n and \nG\n.  Note that not specifying \nG\n amounts to \nG=dy/dt\n.\n\n\n\n\ntspan\n \u2013 tuple \n(start_t,end_t)\n\n\ny0\n \u2013 initial condition\n\n\nF!\n \u2013 in-place \nF\n function \nF!(t,y,res)\n.  If \nF=0\n set to \nnothing\n.\n\n\nG!\n \u2013 in-place \nG\n function \nG!(t,y,dy,res)\n.  If \nG=dy/dt\n then         set to \nnothing\n (or \ndy\n if the solver supports this).  Can         also be a mass matrix for a RHS \nM dy/dt\n\n\nJ!\n \u2013 in-place Jacobian function \nJ!(t,y,dy,res)\n.\n\n\n\n\nTODO: how to fit the sparsity pattern in J?\n\n\nsource\n\n\n#\n\n\nODE.Problem\n \n \nType\n.\n\n\nThis is an iterable type, each call to next(...) produces a next step of a numerical solution to an IVP.\n\n\n\n\nivp: is the prescrived ivp, along with the initial data\n\n\nsolver: the algorithm used to produce subsequent values from the ivp\n\n\n\n\nsource\n\n\n#\n\n\nODE.RKIntegrator\n \n \nType\n.\n\n\nA general Runge-Kutta integrator (it can represent either, a fixed step or an adaptive step algorithm).\n\n\nsource\n\n\n#\n\n\nODE.RKState\n \n \nType\n.\n\n\nState for the Runge-Kutta integrator.\n\n\nsource\n\n\n#\n\n\nODE.RKWorkArrays\n \n \nType\n.\n\n\nPre allocated arrays to store temporary data.  Used only by Runge-Kutta integrator.\n\n\nsource\n\n\n#\n\n\nODE.RosenbrockState\n \n \nType\n.\n\n\nThe state for the Rosenbrock integrator\n\n\n\n\nstep:  Last successful step\n\n\nF1,F2: Work arrays for storing the intermediate values of y'\n\n\nJ:     Jacobian\n\n\niters: Number of successful steps made\n\n\n\n\nsource\n\n\n#\n\n\nODE.Status\n \n \nType\n.\n\n\nHolds the solver status, used inside of \nonestep!\n.\n\n\nValues:\n\n\n\n\ncont \u2013 continue integration\n\n\nabort \u2013 abort integration\n\n\nfinish \u2013 integration reached the end\n\n\n\n\nStatuses can be combined with \n: - cont\ncont == cont - finish\ncont == finish - abort\ncont == abort - abort\nfinish = abort\n\n\nsource\n\n\n#\n\n\nODE.Step\n \n \nType\n.\n\n\nHolds a value of a function and its derivative at time t.  This is usually used to store the solution of an IVP at particular times.\n\n\nsource", 
            "title": "Base"
        }, 
        {
            "location": "/tutorials/euler_integrator/", 
            "text": "Below you will find the simplest implementation of a reasonable generic solver that finds solutions to explicit ODE equations.\n\n\ntype EulerIntegrator \n: AbstractIntegrator\n    # nothing in here yet\nend\n\ntype EulerState\n    t\n    y\n    dy\nend\n\noutput(state::EulerState) = state.t, state.y, state.dy\n\n# see we don't need a fancy constructor\nfunction solver(ode::ExplicitODE,\n                ::Type{EulerIntegrator};\n                options...)\n    return Problem(ode,EulerIntegrator())\nend\n\nfunction init(ode::ExplicitODE, integ::EulerIntegrator)\n    t0, y0 = ode.t0, ode.y0\n    dy0 = similar(ode.dy0)\n    ode.F!(t0,y0,dy0)           # fill in the values of the derivative\n    EulerState(t0,y0,dy0)\nend\n\nfunction onestep!(ode::ExplicitODE, integ::EulerIntegrator, state::EulerState)\n    t, y, dy = output(state)\n    dt = 0.1\n    y += dt*dy\n    t += dt\n    ode.F!(t0,y0,dy0)           # update the derivative\n    return cont\nend\n\n\n\n\nThere are several problems with the above implementation.  First of all, it has a constant prescribed step size.  This could easily be fixed by changing the type definition and the \nsolver\n to\n\n\ntype EulerIntegrator \n: AbstractIntegrator\n    initstep\nend\n\nfunction solver(ode::ExplicitODE,\n                ::Type{EulerIntegrator};\n                initstep = 0.1,\n                options...)\n    return Problem(ode,EulerIntegrator(initstep))\nend\n\n\n\n\nwe should also change the line \ndt = 0.1\n in the \nonestep!\n function to \ndt = stepper.initstep\n.  Now we can run our integrator with a custom step size!\n\n\nsol = solver(ode,EulerIntegrator,initstep = 0.01)\nfor (t,y) in sol\n    if t \n 1\n        print(t,y)\n        break\n    end\nend\n\n\n\n\nAnother issue is type stability, to make \nEulerIntegrator\n perform better we should explicitly annotate the fields in both \nEulerIntegrator\n and \nEulerState\n like this\n\n\ntype EulerIntegrator{T,Y} \n: AbstractIntegrator{T,Y}\n    initstep::T\nend\n\ntype EulerState{T,Y}\n    t::T\n    y::Y\n    dy::Y\nend\n\nfunction solver(ode::ExplicitODE{T,Y},\n                ::Type{EulerIntegrator};\n                initstep::T = T(0.1),\n                options...)\n    return Problem(ode,EulerIntegrator{T,Y}(initstep))\nend\n\n\n\n\nBut the \nEulerState{T,Y}\n is exactly the same as \nStep\n from \nbase.jl\n, so we can simplify it a bit more\n\n\ntype EulerState{T,Y}\n    step::Step{T,Y}\nend\n\n\n\n\nOnce we do that, in the \ninit\n we should change \nEulerState(t0,y0,dy0)\n to \nEulerState(Step(t0,y0,dy0))\n and redefine \noutput\n to \noutput(state::EulerState)=output(state.step)\n (\noutput(::Step)\n is already defined in \nbase.jl\n).\n\n\nOne could even replace \nEulerState\n with \nStep\n completely, but this won't allow us to extend the state with some additional variables and storage space in the future.\n\n\nThe last thing is that our stepper will continue the integration forever: it doesn't have a stopping condition.  We could add one as an option.\n\n\ntype EulerIntegrator{T,Y} \n: AbstractIntegrator{T,Y}\n    initstep::T\n    tstop::T\nend\n\nfunction solver(ode::ExplicitODE{T,Y},\n                ::Type{EulerIntegrator};\n                initstep::T = T(0.1),\n                tstop::T = T(Inf)\n                options...)\n    return Problem(ode,EulerIntegrator{T,Y}(initstep,tstop))\nend\n\nfunction onestep!(ode::ExplicitODE, integ::EulerIntegrator, state::EulerState)\n    t, y, dy = output(state)\n\n    if t \n integ.tstop\n        return finished\n    end\n\n    dt = integ.initstep\n    y += dt*dy\n    t += dt\n    ode.F!(t0,y0,dy0)           # update the derivative\n    return cont\nend\n\n\n\n\nAs a final improvement, we can (although this is not necessary) use a structure \nFixedOptions\n from \noptions.jl\n to keep our options in one structure.  A corresponding options type for adaptive solver is \nAdaptiveOptions\n.  This way we can use the standarized defaults for most options and keep our solver in line with the standard keywords.  Naturally, we have to update \nonestep!\n to use the subtype.\n\n\ntype EulerIntegrator{T,Y} \n: AbstractIntegrator{T,Y}\n    options::FixedOptions{T,Y}\nend\n\nfunction solver(ode::ExplicitODE{T,Y},\n                ::Type{EulerIntegrator};\n                options...)\n    options = FixedOptions{T}(;options...)\n    return Problem(ode,EulerIntegrator{T,Y}(options))\nend", 
            "title": "Fixed step integrator"
        }
    ]
}