<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ODE.jl documentation</title><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script></head><body><nav class="toc"><h1>ODE.jl</h1><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Top-level-interface-1">Top level interface</a></li><li><a class="toctext" href="#Solve-interface-1">Solve interface</a></li><li><a class="toctext" href="#Iterator-interface-1">Iterator interface</a></li><li><a class="toctext" href="#Options-1">Options</a></li><li><a class="toctext" href="#Integrators-1">Integrators</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="man/basics.html">Basics</a></li><li><a class="toctext" href="man/base.html">Base</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaODE/ODE.jl/tree/e47748ba852ebf4f9b1acf4ce0771e577bbe92e5/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><ul><li><a href="man/basics.html#Basic-usage-1">Basic usage</a></li><li><a href="man/base.html#Base-1">Base</a></li><ul><li><a href="man/base.html#General-functions-for-solving-initial-value-problems-1">General functions for solving initial value problems</a></li><li><a href="man/base.html#Predefined-types-of-initial-value-problems-1">Predefined types of initial value problems</a></li><li><a href="man/base.html#Solver-architecture-1">Solver architecture</a></li><li><a href="man/base.html#Fallback-functions-for-solvers-1">Fallback functions for solvers</a></li></ul></ul><h1><a class="nav-anchor" id="ODE.jl-1" href="#ODE.jl-1">ODE.jl</a></h1><h2><a class="nav-anchor" id="Top-level-interface-1" href="#Top-level-interface-1">Top level interface</a></h2><p>If you are looking to getting a solution without the additional hussle of handling an iterator we provide the wrappers <code>ODE.odeXX</code>.  They provide a simplistic way of handling explicit differential equations of the form <code>y&#39;=F(t,y)</code> with <code>y</code> being either a <code>Number</code> or an <code>AbstractArray</code> of any dimension.  Below we solve a simple initial value problem given by <code>y&#39;=y</code> with initial data at <code>t0=0.0</code> and <code>y0=1.0</code> on the interval <code>[t0,1]</code>.</p><div><pre><code class="language-julia">using ODE
tspan  = [0.0,1.0]
y0     = 1.0
F(t,y) = y
(t,y)  = ODE.ode(F,y0,tspan)</code></pre><pre><code class="language-none">([6.05545e-6,3.63327e-5,0.000187719,0.000944651,0.00472931,0.0236526,0.118269,0.295886,0.477652,0.659618,0.841585,1.0],[1.00001,1.00004,1.00019,1.00095,1.00474,1.02393,1.12555,1.34432,1.61228,1.93405,2.32004,2.71828])</code></pre></div><p>The vectors <code>t</code> and <code>y</code> store the time and solution values at the corresponding times.</p><h2><a class="nav-anchor" id="Solve-interface-1" href="#Solve-interface-1">Solve interface</a></h2><p><code>ODE.ode</code> only supports explicit differential equations defined as <code>y&#39;=F(t,y)</code>, for more advenced uses consider using <code>ODE.solve</code>, which was designed to work with a variety of other types of initial value problems and is optimized for better performance.  First we have to define an initial value problem, in our case this is an explicit differential equation <code>y&#39;=y</code> with inital data <code>y0=[1.0]</code> given at the time <code>t0=0.0</code>.</p><div><pre><code class="language-julia">using ODE
t0  = 0.0
y0  = [1.0]
F!(t,y,dy) = dy[1]=y[1]
ode = ODE.ExplicitODE(t0,y0,F!)</code></pre><pre><code class="language-none">ODE.IVP{Float64,Array{Float64,1},ex-solve.#F!,Void,ODE.#jac!#25{ex-solve.#F!,Array{Float64,1}}}(0.0,[1.0],[1.0],ex-solve.F!,nothing,ODE.jac!)</code></pre></div><p>Note that unlike in <code>ODE.ode</code> we now have to supply an in place function <code>F!</code> instead of an explicit function <code>F</code>.  We can solve the ODE problem <code>ode</code> by simply calling</p><div><pre><code class="language-julia">sol = ODE.solve(ode, tstop = 1)</code></pre><pre><code class="language-none">ODE.Solution{Float64,Array{Float64,1}}([6.05545e-6,3.63327e-5,0.000187719,0.000944651,0.00472931,0.0236526,0.118269,0.295886,0.477652,0.659618,0.841585,1.0],Array{Float64,1}[[1.00001],[1.00004],[1.00019],[1.00095],[1.00474],[1.02393],[1.12555],[1.34432],[1.61228],[1.93405],[2.32004],[2.71828]],Array{Float64,1}[[1.00001],[1.00004],[1.00019],[1.00095],[1.00474],[1.02393],[1.12555],[1.34432],[1.61228],[1.93405],[2.32004],[2.71828]])</code></pre></div><p>This returns a <code>Solution</code> type, which stores the solution.  You probably noticed that we passed a keyword argument <code>tstop</code>, this is the final time of integration which we have to specify because <code>tstop</code> defaults to <code>Inf</code> and the integration would carry on forever.  You can access the solution with</p><div><pre><code class="language-julia">(t,y) = sol.t, sol.y</code></pre><pre><code class="language-none">([6.05545e-6,3.63327e-5,0.000187719,0.000944651,0.00472931,0.0236526,0.118269,0.295886,0.477652,0.659618,0.841585,1.0],Array{Float64,1}[[1.00001],[1.00004],[1.00019],[1.00095],[1.00474],[1.02393],[1.12555],[1.34432],[1.61228],[1.93405],[2.32004],[2.71828]])</code></pre></div><p>You can change the default algorithm (Runge-Kutta (4,5)) by passing an optional argument <code>solver</code></p><div><pre><code class="language-julia">sol = ODE.solve(ode, tstop = 1, solver = ODE.RKIntegratorAdaptive{:dopri5})</code></pre><pre><code class="language-none">ODE.Solution{Float64,Array{Float64,1}}([6.05545e-6,3.63327e-5,0.000187719,0.000944651,0.00472931,0.0236526,0.118269,0.313135,0.513576,0.714319,0.915069,1.0],Array{Float64,1}[[1.00001],[1.00004],[1.00019],[1.00095],[1.00474],[1.02393],[1.12555],[1.36771],[1.67126],[2.0428],[2.49695],[2.71828]],Array{Float64,1}[[1.00001],[1.00004],[1.00019],[1.00095],[1.00474],[1.02393],[1.12555],[1.36771],[1.67126],[2.0428],[2.49695],[2.71828]])</code></pre></div><p>For other options accepted by <code>solve</code> see <a href="/Options/">Options</a> below.</p><p>You might still find this interface limiting.  First of all, it stores all the results, so if you are only interested in the final value of <code>y</code> it still stores all the intermediate steps.  Secondly, you cannot process the results on the fly (e.g. plot the current state of a solution).  If you need more control you should consider using the iterator interface.</p><h2><a class="nav-anchor" id="Iterator-interface-1" href="#Iterator-interface-1">Iterator interface</a></h2><p>To offeset the limitations of the <code>ODE.ode</code> interface we implemented a general.  We use the same problem as before as an example</p><div><pre><code class="language-julia">using ODE
t0  = 0.0
y0  = [1.0]
F!(t,y,dy) = dy[1]=y[1]
ode = ODE.ExplicitODE(t0,y0,F!)</code></pre><pre><code class="language-none">ODE.IVP{Float64,Array{Float64,1},ex-iterate.#F!,Void,ODE.#jac!#25{ex-iterate.#F!,Array{Float64,1}}}(0.0,[1.0],[1.0],ex-iterate.F!,nothing,ODE.jac!)</code></pre></div><p>Now we have full flow control over the solver, we can analyze the intermediate results or interrupt the integration at any point.</p><div><pre><code class="language-julia">for (t,y) in ODE.iterate(ode)
    @show (t,y)
    if t &gt; 1
        break
    end
end</code></pre><pre><code class="language-none">(t,y) = (6.055454452393343e-6,[1.00001])
(t,y) = (3.633272671436006e-5,[1.00004])
(t,y) = (0.00018771908802419363,[1.00019])
(t,y) = (0.0009446508945733616,[1.00095])
(t,y) = (0.004729309927319202,[1.00474])
(t,y) = (0.023652605091048398,[1.02393])
(t,y) = (0.11826908090969439,[1.12555])
(t,y) = (0.2958859009223397,[1.34432])
(t,y) = (0.47765152348716255,[1.61228])
(t,y) = (0.6596176824666204,[1.93405])
(t,y) = (0.8415848484689563,[2.32004])
(t,y) = (1.0235443711828829,[2.78304])</code></pre></div><p>Note that we had to break the loop because <code>sol</code> would keep producing the results.  To set the final integration time and other parameters of the integrator <code>integ</code> we can pass optional arguments to <code>ODE.solver</code>.</p><div><pre><code class="language-julia">for (t,y) in ODE.iterate(ode; tstop = 1)
    @show (t,y)
end</code></pre><pre><code class="language-none">(t,y) = (6.055454452393343e-6,[1.00001])
(t,y) = (3.633272671436006e-5,[1.00004])
(t,y) = (0.00018771908802419363,[1.00019])
(t,y) = (0.0009446508945733616,[1.00095])
(t,y) = (0.004729309927319202,[1.00474])
(t,y) = (0.023652605091048398,[1.02393])
(t,y) = (0.11826908090969439,[1.12555])
(t,y) = (0.2958859009223397,[1.34432])
(t,y) = (0.47765152348716255,[1.61228])
(t,y) = (0.6596176824666204,[1.93405])
(t,y) = (0.8415848484689563,[2.32004])
(t,y) = (1.0,[2.71828])</code></pre></div><p>This approach has the added benefit of the solution never exceeding the final time.  Both <code>ODE.iterate</code> and <code>ODE.solve</code> support the same options, so you can easily change the method of integration with the keyword <code>solver</code>.</p><p>Apart from the time and value <code>(t,y)</code> the <code>ODE.solve</code> also returns the derivative, you can retrive it as the third argument in the returned tuple.  In the following example we use it compute the absolute residual error (zero in this case).</p><div><pre><code class="language-julia">for (t,y,dy) in ODE.iterate(ode; tstop = 1)
    err = norm(y-dy)
    @show err
end</code></pre><pre><code class="language-none">err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0
err = 0.0</code></pre></div><p>With <code>tstop</code> specified we can also get all results at once using <code>collect</code> and other constructs working on iterators (e.g. generators).  For example</p><div><pre><code class="language-julia">iter = ODE.iterate(ode; tstop = 1)
solution = collect(iter)</code></pre><pre><code class="language-none">12-element Array{Tuple{Float64,Array{Float64,1},Array{Float64,1}},1}:
 (6.05545e-6,[1.00001],[1.00001])
 (3.63327e-5,[1.00004],[1.00004])
 (0.000187719,[1.00019],[1.00019])
 (0.000944651,[1.00095],[1.00095])
 (0.00472931,[1.00474],[1.00474])
 (0.0236526,[1.02393],[1.02393])
 (0.118269,[1.12555],[1.12555])
 (0.295886,[1.34432],[1.34432])
 (0.477652,[1.61228],[1.61228])
 (0.659618,[1.93405],[1.93405])
 (0.841585,[2.32004],[2.32004])
 (1.0,[2.71828],[2.71828])</code></pre></div><p>returns a vector of triples <code>(t,y,dy)</code>.  Or if you only wan the first component of a solution you could simply use</p><div><pre><code class="language-julia">y1 = collect(y[1] for (t,y) in iter)</code></pre><pre><code class="language-none">12-element Array{Float64,1}:
 1.00001
 1.00004
 1.00019
 1.00095
 1.00474
 1.02393
 1.12555
 1.34432
 1.61228
 1.93405
 2.32004
 2.71828</code></pre></div><p>There are, however, several caveats that you should take into account:</p><ol><li><p>Each time the iterator is collected the differential equation is actually solved, which has potentially high computational cost and might be inefficient.</p></li><li><p>The <code>length</code> is undefined for the result of <code>ODE.iterate</code>, because we don&#39;t know a priori how many steps the integration will require (especially in the case of adaptive solvers).  This means that the functions requireing <code>length</code> might not work.  For the same reason there are no <code>getindex</code> methods.</p></li></ol><h2><a class="nav-anchor" id="Options-1" href="#Options-1">Options</a></h2><p>Both <code>ODE.ode</code> and <code>ODE.solve</code> accept the following keyword arguments.</p><ul><li><p><code>integ</code>: the type of integrator to use, defaults to a adaptive Runge-Kutta method of order 4/5.  To see the list of available integrators see <a href="@ref"><code>Integrators</code></a>.</p></li><li><p><code>initstep</code>: The initial step size, defaults to <code>eps(T)^(1/3)</code>.</p></li><li><p><code>tstop</code>: The final integration time, never exceeded by the integrator.  In case of <code>ODE.ode(F,y0,tspan)</code> this option defaults to the last element of <code>tspan</code> if it is a vector.  In <code>ODE.solve</code> the default is <code>tstop=Inf</code>.  If <code>tstop</code> is smaller then <code>t0</code> the integration runs backwards in time.</p></li></ul><p>Apart from these general options, each integrator has its own keyword arguments.  In particular all integrators with adaptive step size can be cotrolled with</p><ul><li><p><code>reltol</code>, <code>abstol</code>: The relative and absolute error tolerances.  The solution guarantees that at each step we have <code>norm((y-yc)*reltol.+abstol)&lt;=1</code>, where <code>yc</code> is a true solution to and IVP.  Defaults are <code>reltol=eps(T)^(1/3)/10</code>, <code>abstol=eps(T)^(1/2)/10</code>.</p></li><li><p><code>norm</code>: The norm used to measure error in the formula above, defaults to <code>y-&gt;Base.vecnorm(y,Inf)</code>.  You can specify it to assign different weights to different components of <code>y</code>.</p></li><li><p><code>minstep</code>, <code>maxstep</code>: Minimal and maximal stepsize for the integrator.  If at any point the stepsize exceeds these limits the integrator will yield an error and cease producing results.  Deafaults are <code>minstep=10*eps(T)</code> and <code>maxstep=1/minstep</code>.</p></li><li><p><code>maxiters</code>: The number of iterations before the integrator ceases to work, defaults to <code>Inf</code>.  Useful as a safeguard from iterator continuing ad infinitum.</p></li><li><p><code>isoutofdomain</code>: Applied to each component of <code>y</code>, if <code>isoutofdomain(y[i])==true</code> the integrator stops.  Defaults to <code>Base.isnan</code>.</p></li></ul><p>Apart from these, each integrator may support additional options.</p><h2><a class="nav-anchor" id="Integrators-1" href="#Integrators-1">Integrators</a></h2><h3><a class="nav-anchor" id="Explicit-Runge-Kutta-integrators-1" href="#Explicit-Runge-Kutta-integrators-1">Explicit Runge-Kutta integrators</a></h3><h3><a class="nav-anchor" id="Rosenbrock-methods-1" href="#Rosenbrock-methods-1">Rosenbrock methods</a></h3><h3><a class="nav-anchor" id="Backwards-differential-formula-(BDF)-methods-1" href="#Backwards-differential-formula-(BDF)-methods-1">Backwards differential formula (BDF) methods</a></h3><h3><a class="nav-anchor" id="???-1" href="#???-1">???</a></h3><footer><hr/><a class="next" href="man/basics.html"><span class="direction">Next</span><span class="title">Basics</span></a></footer></article></body></html>
