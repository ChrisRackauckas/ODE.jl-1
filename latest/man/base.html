<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Base · ODE.jl documentation</title><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script></head><body><nav class="toc"><h1>ODE.jl</h1><form class="search" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="basics.html">Basics</a></li><li class="current"><a class="toctext" href="base.html">Base</a><ul class="internal"><li><a class="toctext" href="#General-functions-for-solving-initial-value-problems-1">General functions for solving initial value problems</a></li><li><a class="toctext" href="#Predefined-types-of-initial-value-problems-1">Predefined types of initial value problems</a></li><li><a class="toctext" href="#Solver-architecture-1">Solver architecture</a></li><li><a class="toctext" href="#Fallback-functions-for-solvers-1">Fallback functions for solvers</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="base.html">Base</a></li></ul><a class="edit-page" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/docs/src/man/base.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="Base-1" href="#Base-1">Base</a></h1><p>The file <code>base.jl</code> implements the most basic iterator infrastructure for solvers and the definitions of the types representing general IVP (initial value problem) and solvers.</p><h2><a class="nav-anchor" id="General-functions-for-solving-initial-value-problems-1" href="#General-functions-for-solving-initial-value-problems-1">General functions for solving initial value problems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.solve" href="#ODE.solve"><code>ODE.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">solve(ivp::IVP; solver=RKIntegratorAdaptive{:rk45}, opts...)</code></pre><p>Solve the initial value problem <code>ivp</code> using an algorithm <code>solver</code> (defaults to Runge-Kutta (4,5) integrator).  One can pass additional options to the <code>solver</code> via keyword arguments to <code>solve</code> (here denoted as <code>options</code>).  The output is a <code>Solution</code> type (currently simply a tuple of vectors <code>(Vector{T},Vector{Y})</code>, where <code>T,Y=eltype(ivp)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L251-L260">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.iterate" href="#ODE.iterate"><code>ODE.iterate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">iterate(ivp::IVP; solver=RKIntegratorAdaptive{:rk45}, opts...)</code></pre><p>Iterate creates an iterable <code>Problem</code> instance from an <code>IVP</code> instance (specifying the math) and from a <code>Type{AbstractSolver}</code> (the numerical integrator).  The simplest use case is</p><pre><code class="language-none">for (t,y,dy) in iterate(...)
    # do something with t, y an dy
end</code></pre><p>If the integration interval, defined by the keyword argument <code>tstop</code>, is finite you can request all the results at once by calling</p><pre><code class="language-none">collect(iterate(...)) # =&gt; Vector{Tuple{T,Y,Y}}</code></pre><p>Notes:</p><ul><li><p>usually solvers require the ivp to be in a certain form, say an</p></li></ul><p><code>ExplicitODE</code>.</p><ul><li><p>the second argument is the <em>Type</em> of the solver and not an instance. The instance of the solve can only be created together with the <code>ivp</code> as their type parameters need to match.</p></li></ul><p>Input:</p><ul><li><p><code>ivp::IVP</code></p></li><li><p><code>S::Type{AbstractSolver}</code></p></li></ul><p>Output:</p><ul><li><p><code>::Problem</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L211-L244">source</a><br/></section><h2><a class="nav-anchor" id="Predefined-types-of-initial-value-problems-1" href="#Predefined-types-of-initial-value-problems-1">Predefined types of initial value problems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.AbstractIVP" href="#ODE.AbstractIVP"><code>ODE.AbstractIVP</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractIVP{T,Y}</code></pre><p>The abstract supertype of all IVPs (initial value problems).  The type parameters <code>T</code> and <code>Y</code> correspond to the types of time and state variable respectively.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L10-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.IVP" href="#ODE.IVP"><code>ODE.IVP</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IVP{T,Y,F,G,J} &lt;: AbstractIVP{T,Y}</code></pre><p>Defines the mathematical part of an IVP (initial value problem) specified in the general form:</p><p><code>F(t, y) =  G(t, y, dy)</code> with <code>y(t0)= y0</code></p><p>Depending on the combination of the parameters this type can represent a wide range of problems, including ODE, DAE and IMEX.  Nevertheless not all solvers will support any combinations of <code>F</code> and <code>G</code>.  Note that not specifying <code>G</code> amounts to <code>G=dy/dt</code>.</p><ul><li><p><code>tspan</code> – tuple <code>(start_t,end_t)</code></p></li><li><p><code>y0</code> – initial condition</p></li><li><p><code>F!</code> – in-place <code>F</code> function <code>F!(t,y,res)</code>.  If <code>F=0</code> set to <code>nothing</code>.</p></li><li><p><code>G!</code> – in-place <code>G</code> function <code>G!(t,y,dy,res)</code>.  If <code>G=dy/dt</code> then         set to <code>nothing</code> (or <code>dy</code> if the solver supports this).  Can         also be a mass matrix for a RHS <code>M dy/dt</code></p></li><li><p><code>J!</code> – in-place Jacobian function <code>J!(t,y,dy,res)</code>.</p></li></ul><p>TODO: how to fit the sparsity pattern in J?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L25-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.ExplicitODE" href="#ODE.ExplicitODE"><code>ODE.ExplicitODE</code></a> — <span class="docstring-category">Constant</span>.</div><div><pre><code class="language-none">typealias ExplicitODE{T,Y,F,J} IVP{T,Y,F,Void,J}</code></pre><p>Can be constructed by calling</p><pre><code class="language-none">ODE.ExplicitODE(t0,y0,F!;J!=jacobian))</code></pre><p>Explicit ODE representing the problem</p><p><code>dy = F(t,y)</code> with <code>y(t0)=y0</code></p><ul><li><p>t0, y0: initial conditions</p></li><li><p>F!: in place version of <code>F</code> called by <code>F!(t,y,dy)</code></p></li><li><p>J!: (optional) computes <code>J=dF/dy</code> in place, called with <code>J!(t,y,J)</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L61-L77">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.ImplicitODE" href="#ODE.ImplicitODE"><code>ODE.ImplicitODE</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Implicit ODE representing the problem</p><p><code>G(t,y,dy)=0</code> with <code>y(t0)=y0</code> and optionally <code>y&#39;(t0)=dy0</code></p><ul><li><p>t0, y0: initial conditions</p></li><li><p>G!: in place version of <code>G</code> called by <code>G!(res,t,y,dy)</code>,     returns residual in-place in <code>res</code>.</p></li><li><p>J!: (optional) computes <code>J=dF/dy+a*dF/dy&#39;</code> for prescribed <code>a</code>, called with <code>J!(out,t,y,dy,a)</code>.     Returns Jacobian in-place in <code>out</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L90-L102">source</a><br/></section><h2><a class="nav-anchor" id="Solver-architecture-1" href="#Solver-architecture-1">Solver architecture</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.AbstractSolver" href="#ODE.AbstractSolver"><code>ODE.AbstractSolver</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">AbstractSolver</code></pre><p>The supertype of anything which can get you to a solution of a IVP. Subtypes include: <code>AbstractIntegrator</code>s but also <code>DenseOutput</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L113-L120">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.AbstractIntegrator" href="#ODE.AbstractIntegrator"><code>ODE.AbstractIntegrator</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The abstract type of the actual algorithm to solve an IVP.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L135-L139">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.AbstractState" href="#ODE.AbstractState"><code>ODE.AbstractState</code></a> — <span class="docstring-category">Type</span>.</div><div><p>AbstractState keeps the temporary data (state) for the iterator Problem{::AbstractIntegrator}.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L143-L148">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ODE.Solution" href="#ODE.Solution"><code>ODE.Solution</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Stores a solution to the <code>ivp</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaODE/ODE.jl/tree/5005e3111b331c186751dcba511125de9b7cdb79/src/base.jl#L298-L302">source</a><br/></section><p>The fallback constructor for <code>AbstractSolver(ivp::IVP;opts...)</code> ensures that an error is thrown if a solver is constructed for an unsupported type of the given IVP.</p><h2><a class="nav-anchor" id="Fallback-functions-for-solvers-1" href="#Fallback-functions-for-solvers-1">Fallback functions for solvers</a></h2><pre><code class="language-none">Base.length(::AbstractSolver)
output(::AbstractState)
Base.eltype{T,Y}(::Type{AbstractIVP{T,Y}})</code></pre><footer><hr/><a class="previous" href="basics.html"><span class="direction">Previous</span><span class="title">Basics</span></a></footer></article></body></html>
